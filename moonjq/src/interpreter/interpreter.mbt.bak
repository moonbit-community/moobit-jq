///|
/// Interpreter error types
pub(all) suberror InterpreterError {
  TypeMismatch(String, String) // (expected, got)
  KeyNotFound(String)
  IndexOutOfBounds(Int)
  InvalidOperation(String)
  DivisionByZero
} derive(Eq, Show)

///|
/// Environment for variable bindings
struct Env {
  bindings : Map[String, @json.Json]
}

///|
fn Env::new() -> Env {
  { bindings: {} }
}

///|
fn Env::get(self : Env, name : String) -> @json.Json? {
  self.bindings.get(name)
}

///|
fn Env::set(self : Env, name : String, value : @json.Json) -> Env {
  let new_bindings = self.bindings
  new_bindings[name] = value
  { bindings: new_bindings }
}

///|
/// Evaluate an expression with input JSON, returns iterator of results
pub fn eval(expr : @ast.Expr, input : @json.Json) -> Iter[@json.Json] raise {
  eval_with_env(expr, input, Env::new())
}

///|
/// Evaluate with environment
fn eval_with_env(
  expr : @ast.Expr,
  input : @json.Json,
  env : Env
) -> Iter[@json.Json] raise InterpreterError {
  match expr {
    // Identity returns input as-is
    @ast.Expr::Identity => Iter::singleton(input)
    
    // Literals ignore input and return the literal value
    @ast.Expr::Literal(lit) => Iter::singleton(eval_literal(lit))
    
    // Pipe: feed results of left into right
    @ast.Expr::Pipe(left, right) => {
      eval_with_env(left, input, env).flat_map(fn(val) {
        eval_with_env(right, val, env)
      })
    }
    
    // Comma: produce multiple outputs
    @ast.Expr::Comma(left, right) => {
      Iter::concat([eval_with_env(left, input, env), eval_with_env(right, input, env)])
    }
    
    // Field access
    @ast.Expr::Key(key) => {
      match input {
        @json.Json::Object(obj) =>
          match obj.get(key) {
            Some(v) => Iter::singleton(v)
            None => Iter::singleton(@json.Json::Null)
          }
        _ => Iter::singleton(@json.Json::Null)
      }
    }
    
    // Array indexing and iteration
    @ast.Expr::Index(indices) => {
      if indices.is_empty() {
        // Empty index means iterate over array/object values
        match input {
          @json.Json::Array(arr) => Iter::from_array(arr)
          @json.Json::Object(obj) => {
            let mut values : Array[@json.Json] = []
            for _k, v in obj {
              values = values + [v]
            }
            Iter::from_array(values)
          }
          _ => Iter::empty()
        }
      } else {
        // Multiple indices produce multiple results
        Iter::from_array(indices).map(fn(idx) {
          match input {
            @json.Json::Array(arr) => {
              let i = if idx < 0 { arr.length() + idx } else { idx }
              if i >= 0 && i < arr.length() {
                arr[i]
              } else {
                @json.Json::Null
              }
            }
            _ => @json.Json::Null
          }
        })
      }
    }
    
    // Array slicing
    @ast.Expr::Slice(start, end) => {
      match input {
        @json.Json::Array(arr) => {
          let len = arr.length()
          let s = match start {
            Some(n) => if n < 0 { len + n } else { n }
            None => 0
          }
          let e = match end {
            Some(n) => if n < 0 { len + n } else { n }
            None => len
          }
          let mut result : Array[@json.Json] = []
          for i = s; i < e && i < len; i = i + 1 {
            if i >= 0 {
              result = result + [arr[i]]
            }
          }
          Iter::singleton(@json.Json::Array(result))
        }
        _ => Iter::singleton(@json.Json::Null)
      }
    }
    
    // Optional: suppress errors and return empty on failure
    @ast.Expr::Optional(inner) => {
      try eval_with_env(inner, input, env) catch {
        _ => Iter::empty()
      }
    }
    
    // Array construction
    @ast.Expr::ArrayConstruct(expr_opt) => {
      match expr_opt {
        None => Iter::singleton(@json.Json::Array([]))
        Some(e) => {
          let results = eval_with_env(e, input, env).collect()
          Iter::singleton(@json.Json::Array(results))
        }
      }
    }
    
    // Object construction
    @ast.Expr::ObjectConstruct(pairs) => {
      let obj : Map[String, @json.Json] = {}
      for (key_expr, value_expr_opt) in pairs {
        // Evaluate key to get string
        let key_results = eval_with_env(key_expr, input, env).collect()
        if key_results.is_empty() {
          continue
        }
        let key_str = match key_results[0] {
          @json.Json::String(s) => s
          _ => raise InterpreterError::TypeMismatch("string", @json.type_name(key_results[0]))
        }
        
        // Evaluate value or use key from input
        let value = match value_expr_opt {
          Some(value_expr) => {
            let value_results = eval_with_env(value_expr, input, env).collect()
            if value_results.is_empty() {
              @json.Json::Null
            } else {
              value_results[0]
            }
          }
          None => {
            // Shorthand: {foo} means {foo: .foo}
            match input {
              @json.Json::Object(input_obj) =>
                match input_obj.get(key_str) {
                  Some(v) => v
                  None => @json.Json::Null
                }
              _ => @json.Json::Null
            }
          }
        }
        obj[key_str] = value
      }
      Iter::singleton(@json.Json::Object(obj))
    }
    
    // Binary operations
    @ast.Expr::Operation(left, op, right) => {
      eval_with_env(left, input, env).flat_map(fn(left_val) {
        eval_with_env(right, input, env).map(fn(right_val) {
          eval_binary_op(op, left_val, right_val)
        })
      })
    }
    
    // Built-in functions
    @ast.Expr::Length => {
      let len = match input {
        @json.Json::Array(arr) => arr.length()
        @json.Json::Object(obj) => obj.length()
        @json.Json::String(s) => s.length()
        @json.Json::Null => 0
        _ => raise InterpreterError::TypeMismatch("array/object/string", @json.type_name(input))
      }
      Iter::singleton(@json.Json::Number(len.to_double()))
    }
    
    @ast.Expr::Keys => {
      match input {
        @json.Json::Object(obj) => {
          let mut keys : Array[@json.Json] = []
          for k, _v in obj {
            keys = keys + [@json.Json::String(k)]
          }
          Iter::singleton(@json.Json::Array(keys))
        }
        @json.Json::Array(arr) => {
          let mut indices : Array[@json.Json] = []
          for i = 0; i < arr.length(); i = i + 1 {
            indices = indices + [@json.Json::Number(i.to_double())]
          }
          Iter::singleton(@json.Json::Array(indices))
        }
        _ => raise InterpreterError::TypeMismatch("object/array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Values => {
      match input {
        @json.Json::Object(obj) => {
          let mut values : Array[@json.Json] = []
          for _k, v in obj {
            values = values + [v]
          }
          Iter::singleton(@json.Json::Array(values))
        }
        @json.Json::Array(arr) => Iter::singleton(@json.Json::Array(arr))
        _ => raise InterpreterError::TypeMismatch("object/array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Type => {
      Iter::singleton(@json.Json::String(@json.type_name(input)))
    }
    
    @ast.Expr::Empty => Iter::empty()
    
    @ast.Expr::Not => {
      let is_false = match input {
        @json.Json::False | @json.Json::Null => true
        _ => false
      }
      Iter::singleton(@json.Json::boolean(is_false))
    }
    
    // Array functions
    @ast.Expr::Map(inner) => {
      match input {
        @json.Json::Array(arr) => {
          let mut results : Array[@json.Json] = []
          for elem in arr {
            let mapped = eval_with_env(inner, elem, env).collect()
            results = results + mapped
          }
          Iter::singleton(@json.Json::Array(results))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Select(condition) => {
      let cond_results = eval_with_env(condition, input, env).collect()
      if cond_results.is_empty() {
        Iter::empty()
      } else {
        let is_truthy = match cond_results[0] {
          @json.Json::False | @json.Json::Null => false
          _ => true
        }
        if is_truthy {
          Iter::singleton(input)
        } else {
          Iter::empty()
        }
      }
    }
    
    @ast.Expr::Sort => {
      match input {
        @json.Json::Array(arr) => {
          let sorted = arr.copy()
          sorted.sort_by(compare_json)
          Iter::singleton(@json.Json::Array(sorted))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Reverse => {
      match input {
        @json.Json::Array(arr) => {
          let mut reversed : Array[@json.Json] = []
          for i = arr.length() - 1; i >= 0; i = i - 1 {
            reversed = reversed + [arr[i]]
          }
          Iter::singleton(@json.Json::Array(reversed))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Flatten(depth_opt) => {
      match input {
        @json.Json::Array(arr) => {
          let depth = match depth_opt {
            Some(d) => d
            None => 999999 // Flatten all levels
          }
          Iter::singleton(@json.Json::Array(flatten_array(arr, depth)))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Unique => {
      match input {
        @json.Json::Array(arr) => {
          let sorted = arr.copy()
          sorted.sort_by(compare_json)
          let mut unique : Array[@json.Json] = []
          let mut prev : @json.Json? = None
          for elem in sorted {
            match prev {
              None => {
                unique = unique + [elem]
                prev = Some(elem)
              }
              Some(p) =>
                if compare_json(p, elem) != 0 {
                  unique = unique + [elem]
                  prev = Some(elem)
                }
            }
          }
          Iter::singleton(@json.Json::Array(unique))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    // Numeric functions
    @ast.Expr::Add => {
      match input {
        @json.Json::Array(arr) => {
          let mut sum = 0.0
          for elem in arr {
            match elem {
              @json.Json::Number(n) => sum = sum + n
              _ => ()
            }
          }
          Iter::singleton(@json.Json::Number(sum))
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Floor => {
      match input {
        @json.Json::Number(n) => Iter::singleton(@json.Json::Number(n.floor()))
        _ => raise InterpreterError::TypeMismatch("number", @json.type_name(input))
      }
    }
    
    @ast.Expr::Sqrt => {
      match input {
        @json.Json::Number(n) => Iter::singleton(@json.Json::Number(n.sqrt()))
        _ => raise InterpreterError::TypeMismatch("number", @json.type_name(input))
      }
    }
    
    @ast.Expr::Min => {
      match input {
        @json.Json::Array(arr) => {
          if arr.is_empty() {
            Iter::singleton(@json.Json::Null)
          } else {
            let mut min_val = arr[0]
            for elem in arr {
              if compare_json(elem, min_val) < 0 {
                min_val = elem
              }
            }
            Iter::singleton(min_val)
          }
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    @ast.Expr::Max => {
      match input {
        @json.Json::Array(arr) => {
          if arr.is_empty() {
            Iter::singleton(@json.Json::Null)
          } else {
            let mut max_val = arr[0]
            for elem in arr {
              if compare_json(elem, max_val) > 0 {
                max_val = elem
              }
            }
            Iter::singleton(max_val)
          }
        }
        _ => raise InterpreterError::TypeMismatch("array", @json.type_name(input))
      }
    }
    
    // Control flow
    @ast.Expr::IfThenElse(cond, then_expr, else_expr) => {
      let cond_results = eval_with_env(cond, input, env).collect()
      if cond_results.is_empty() {
        eval_with_env(else_expr, input, env)
      } else {
        let is_truthy = match cond_results[0] {
          @json.Json::False | @json.Json::Null => false
          _ => true
        }
        if is_truthy {
          eval_with_env(then_expr, input, env)
        } else {
          eval_with_env(else_expr, input, env)
        }
      }
    }
    
    @ast.Expr::TryCatch(try_expr, catch_opt) => {
      try eval_with_env(try_expr, input, env) catch {
        _ =>
          match catch_opt {
            Some(catch_expr) => eval_with_env(catch_expr, input, env)
            None => Iter::empty()
          }
      }
    }
    
    // Variables
    @ast.Expr::Variable(name) => {
      match env.get(name) {
        Some(v) => Iter::singleton(v)
        None => raise InterpreterError::InvalidOperation("Undefined variable: $\{name}")
      }
    }
    
    // Recursive descent
    @ast.Expr::Recurse => {
      recurse_all(input)
    }
    
    // Alternative operator: return left, or right if left produces empty/null
    @ast.Expr::Alternative(left, right) => {
      let left_results = eval_with_env(left, input, env).collect()
      if left_results.is_empty() {
        eval_with_env(right, input, env)
      } else {
        match left_results[0] {
          @json.Json::Null | @json.Json::False => eval_with_env(right, input, env)
          _ => Iter::from_array(left_results)
        }
      }
    }
    
    // Not yet implemented features
    _ => raise InterpreterError::InvalidOperation("Feature not yet implemented: \{expr}")
  }
}

///|
/// Evaluate a literal to JSON
fn eval_literal(lit : @ast.Literal) -> @json.Json {
  match lit {
    @ast.Literal::Null => @json.Json::Null
    @ast.Literal::Bool(b) => @json.Json::boolean(b)
    @ast.Literal::Number(n) => @json.Json::Number(n)
    @ast.Literal::String(s) => @json.Json::String(s)
  }
}

///|
/// Evaluate binary operation
fn eval_binary_op(
  op : @ast.BinaryOp,
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match op {
    @ast.BinaryOp::Add => json_add(left, right)
    @ast.BinaryOp::Subtract => json_subtract(left, right)
    @ast.BinaryOp::Multiply => json_multiply(left, right)
    @ast.BinaryOp::Divide => json_divide(left, right)
    @ast.BinaryOp::Modulo => json_modulo(left, right)
    @ast.BinaryOp::Equal => @json.Json::boolean(compare_json(left, right) == 0)
    @ast.BinaryOp::NotEqual => @json.Json::boolean(compare_json(left, right) != 0)
    @ast.BinaryOp::LessThan => @json.Json::boolean(compare_json(left, right) < 0)
    @ast.BinaryOp::LessEq => @json.Json::boolean(compare_json(left, right) <= 0)
    @ast.BinaryOp::GreaterThan => @json.Json::boolean(compare_json(left, right) > 0)
    @ast.BinaryOp::GreaterEq => @json.Json::boolean(compare_json(left, right) >= 0)
    @ast.BinaryOp::And => {
      let left_truthy = match left {
        @json.Json::False | @json.Json::Null => false
        _ => true
      }
      if left_truthy {
        right
      } else {
        @json.Json::False
      }
    }
    @ast.BinaryOp::Or => {
      let left_truthy = match left {
        @json.Json::False | @json.Json::Null => false
        _ => true
      }
      if left_truthy {
        left
      } else {
        right
      }
    }
  }
}

///|
/// Arithmetic operations
fn json_add(
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match (left, right) {
    (@json.Json::Number(a), @json.Json::Number(b)) => @json.Json::Number(a + b)
    (@json.Json::String(a), @json.Json::String(b)) => @json.Json::String(a + b)
    (@json.Json::Array(a), @json.Json::Array(b)) => @json.Json::Array(a + b)
    (@json.Json::Object(a), @json.Json::Object(b)) => {
      let result = a
      for k, v in b {
        result[k] = v
      }
      @json.Json::Object(result)
    }
    _ =>
      raise InterpreterError::InvalidOperation(
        "Cannot add \{@json.type_name(left)} and \{@json.type_name(right)}",
      )
  }
}

///|
fn json_subtract(
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match (left, right) {
    (@json.Json::Number(a), @json.Json::Number(b)) => @json.Json::Number(a - b)
    (@json.Json::Array(a), @json.Json::Array(b)) => {
      let mut result : Array[@json.Json] = []
      for elem in a {
        let mut found = false
        for r in b {
          if compare_json(elem, r) == 0 {
            found = true
            break
          }
        }
        if not(found) {
          result = result + [elem]
        }
      }
      @json.Json::Array(result)
    }
    _ =>
      raise InterpreterError::InvalidOperation(
        "Cannot subtract \{@json.type_name(right)} from \{@json.type_name(left)}",
      )
  }
}

///|
fn json_multiply(
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match (left, right) {
    (@json.Json::Number(a), @json.Json::Number(b)) => @json.Json::Number(a * b)
    (@json.Json::String(s), @json.Json::Number(n)) | (@json.Json::Number(n), @json.Json::String(s)) => {
      let count = n.to_int()
      let mut result = ""
      for _i = 0; _i < count; _i = _i + 1 {
        result = result + s
      }
      @json.Json::String(result)
    }
    _ =>
      raise InterpreterError::InvalidOperation(
        "Cannot multiply \{@json.type_name(left)} and \{@json.type_name(right)}",
      )
  }
}

///|
fn json_divide(
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match (left, right) {
    (@json.Json::Number(a), @json.Json::Number(b)) => {
      if b == 0.0 {
        raise InterpreterError::DivisionByZero
      }
      @json.Json::Number(a / b)
    }
    _ =>
      raise InterpreterError::InvalidOperation(
        "Cannot divide \{@json.type_name(left)} by \{@json.type_name(right)}",
      )
  }
}

///|
fn json_modulo(
  left : @json.Json,
  right : @json.Json
) -> @json.Json raise InterpreterError {
  match (left, right) {
    (@json.Json::Number(a), @json.Json::Number(b)) => {
      if b == 0.0 {
        raise InterpreterError::DivisionByZero
      }
      @json.Json::Number(a % b)
    }
    _ =>
      raise InterpreterError::InvalidOperation(
        "Cannot modulo \{@json.type_name(left)} by \{@json.type_name(right)}",
      )
  }
}

///|
/// Compare JSON values for sorting
fn compare_json(a : @json.Json, b : @json.Json) -> Int {
  match (a, b) {
    (@json.Json::Null, @json.Json::Null) => 0
    (@json.Json::Null, _) => -1
    (_, @json.Json::Null) => 1
    (@json.Json::False, @json.Json::False) => 0
    (@json.Json::False, @json.Json::True) => -1
    (@json.Json::True, @json.Json::False) => 1
    (@json.Json::True, @json.Json::True) => 0
    (@json.Json::Number(x), @json.Json::Number(y)) => x.compare(y)
    (@json.Json::String(x), @json.Json::String(y)) => x.compare(y)
    (@json.Json::Array(x), @json.Json::Array(y)) => {
      let min_len = if x.length() < y.length() { x.length() } else { y.length() }
      for i = 0; i < min_len; i = i + 1 {
        let cmp = compare_json(x[i], y[i])
        if cmp != 0 {
          return cmp
        }
      }
      x.length().compare(y.length())
    }
    // Type ordering: null < bool < number < string < array < object
    (@json.Json::False | @json.Json::True, @json.Json::Number(_)) => -1
    (@json.Json::Number(_), @json.Json::False | @json.Json::True) => 1
    (@json.Json::Number(_), @json.Json::String(_)) => -1
    (@json.Json::String(_), @json.Json::Number(_)) => 1
    (@json.Json::String(_), @json.Json::Array(_)) => -1
    (@json.Json::Array(_), @json.Json::String(_)) => 1
    (@json.Json::Array(_), @json.Json::Object(_)) => -1
    (@json.Json::Object(_), @json.Json::Array(_)) => 1
    (@json.Json::Object(_), @json.Json::Object(_)) => 0 // Objects compare equal
    _ => 0
  }
}

///|
/// Flatten array to specified depth
fn flatten_array(arr : Array[@json.Json], depth : Int) -> Array[@json.Json] {
  if depth <= 0 {
    return arr
  }
  let mut result : Array[@json.Json] = []
  for elem in arr {
    match elem {
      @json.Json::Array(inner) => {
        result = result + flatten_array(inner, depth - 1)
      }
      _ => result = result + [elem]
    }
  }
  result
}

///|
/// Recursive descent: yield input and all nested values
fn recurse_all(input : @json.Json) -> Iter[@json.Json] {
  Iter::concat([
    Iter::singleton(input),
    match input {
      @json.Json::Array(arr) => {
        Iter::from_array(arr).flat_map(recurse_all)
      }
      @json.Json::Object(obj) => {
        let mut values : Array[@json.Json] = []
        for _k, v in obj {
          values = values + [v]
        }
        Iter::from_array(values).flat_map(recurse_all)
      }
      _ => Iter::empty()
    },
  ])
}
